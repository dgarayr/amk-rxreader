# Introduction

The *amk-tools* package provides a set of tools for reading & parsing AutoMeKin output as NetworkX graph objects in Python, and interactive visualization tools based on the Bokeh library.

-   RXReader (**arx**). Handles network I/O and processing, using the `RXNet` files generated by AutoMeKin.
-   RXVisualizer (**arxviz**). Generates Bokeh-based interactive dashboards for the reaction networks processed by *RXReader*, containing:
    - Interactive network plot, allowing the user to zoom and move around. Hovering over nodes or edges shows the corresponding name and energy.
    - JSMol instance to display 3D models of the selected node/edge in the network, including vibrational normal modes.
    - Visualization of energy profiles along the network, which may be filtered by energy or by the presence of a given species.

These dashboards are generated as independent HTML files, not requiring a live Python server.

# Workflow
To parse a network, `RXReader` requires the name of the corresponding `FINAL_LL_...` or `FINAL_HL_...` folder generated by AutoMeKin and the name of the requested reaction network file, which can be full (**RXNet**), coarse-grained (**RXNet.cg**) or simplified, containing only the most relevant paths (**RXNet.rel**).
```python
    import RXReader as arx
    finaldir = "FINAL_LL_MOL"
    rxnfile = "RXNet.cg"
    # The text file is first read into a list of tags and indices
    data = arx.RX_parser(finaldir,rxnfile)
    # Connectivity data is used to generate the graph, and then the SQLite databases for transition states and minima are queried to recover all information
    G = arx.RX_builder(finaldir,data)
```
The resulting graph object contains all the information available on the SQLite databases (geometries, energies and frequencies). Through this graph object, it is possible to easily work with the network: for example, generating a simple visualization via Matplotlib (`arx.graph_plotter()`) or to generate the corresponding energy profiles.

This profile generation can take place in two main ways, both accessed through the general `arx.add_paths()` wrapper:
1. Exhaustive generation of possible pathways along the network, via `arx.theor_cycle_branch_builder(G,start_node)`. Slow for large networks (needs to search along all possible cycles).
2. Location of specific paths connecting a source node (or list of source nodes) to a target node (or list of target nodes), via `arx.poly_path_finder(G,source_collection,target_collection,cutoff)`. The function automatically generates all required source/target combinations, and does a simple graph traversal of length **cutoff** to find the paths for each combination.
   + It is also possible to search for the /formula/ of a given product, generating the list of all PROD nodes matching the formula, using `arx.formula_locator(G,formula)`, and then using this list as *source_collection* or *target_collection*. 
   
These profiles are saved as a graph property (**pathList**), and can be used for further processing: filtering by energy (`arx.path_filter(G,path_list,energy_threshold)`), subsetting the graph to only keep the nodes in the requested paths (`arx.graph_path_selector(G,path_list)`)... or to generate a basic Matplotlib view through `arx.theor_profile_plotter(G,path_list)`.

The `RXVisualizer` module provides advanced visualization capabilities, allowing to easily create a Bokeh dashboard with the following features.

-   Network visualization, including panning and zooming tools. Hovering over nodes or edges shows the corresponding energy values.
-   3D molecule visualization powered by JSMol, by click-selecting a node or edge in the network.
-   Visualization of vibrational modes.
-   Automatic dump of the coordinates of the selected molecule to the clipboard.
-   Location of structures by name for large networks.
-   Visualization of energy profiles, from pre-loaded pathways stored in **path_list**.
-   Filtering of energy profiles, by energy or by the presence of a selected node/edge.

A basic Python script allowing to generate a complete visualization from scratch is provided as reference.
``` python
    import RXReader as arx
    import RXVisualizer as arxviz
    import networkx as nx
    
    # Parsing
    finaldir = "FINAL_LL_MOL"
    rxnfile = "RXNet.cg"
    data = arx.RX_parser(finaldir,rxnfile)
    G = arx.RX_builder(finaldir,data)
    
    posx = nx.kamada_kawai_layout(G)
    
    # From the graph G read in the parsing step:
    arxviz.add_models(G)                          # add XYZ geometry models to the graph
    arx.vibr_displ_parser(finaldir,G)             # locate ALL normal modes and add them to the graph
    arxviz.add_vibr_models(G)                     # add geometry models to the graph
    arx.add_paths(G,["MIN1"],["PR1","PR2"])       # add all paths from MIN1 to PR1 and PR2
    # Set up visualization
    bk_fig,bk_graph = arxviz.bokeh_network_view(G,positions=posx)
    layout = arxviz.full_view_layout(bk_fig,bk_graph)
    # Save to HTML file
    bokeh.plotting.output_file("Network.html",title="Network visualization for MOL")
```

The wrapper function `arxviz.generate_visualization()` allows to simplify the protocol above:
``` python
    import RXReader as arx
    import RXVisualizer as arxviz
    # Parsing
    finaldir = "FINAL_LL_MOL"
    rxnfile = "RXNet.cg"
    data = arx.RX_parser(finaldir,rxnfile)
    G = arx.RX_builder(finaldir,data)
   
    lay = arxviz.generate_visualization()
    # From the graph G read in the parsing step:
    arxviz.add_models(G)                          # add XYZ geometry models to the graph
    arx.vibr_displ_parser(finaldir,G)             # locate ALL normal modes and add them to the graph
    arxviz.add_vibr_models(G)                     # add geometry models to the graph
    arx.add_paths(G,["MIN1"],["PR1","PR2"])       # add all paths from MIN1 to PR1 and PR2
    # Set up visualization
    bk_fig,bk_graph = arxviz.bokeh_network_view(G,positions=posx)
    layout = arxviz.full_view_layout(bk_fig,bk_graph)
    # Save to HTML file
    bokeh.plotting.output_file("Network.html",title="Network visualization for MOL")
```


Alternatively, the more simple commandline script `amk_gen_view.py` allows to generate visualizations directly taking arguments from STDIN. If the corresponding directory is in the *PATH*:

`$amk_gen_view.py FINALDIR RXNFILE`, where **FINALDIR** is the folder containing AMK results and **RXNFILE** is the name of the RXNet file to be used (RXNet, RXNet.cg or RXNet.rel). Additional arguments that may be passed are:

- **--barrierless**. Include the barrierless routes stored in *RXNet.barrless*.
- **--vibrations NVIBR**. Add only *NVIBR* normal modes to the visualization. Default is -1, meaning that ALL modes are included.
- **--paths [SOURCE] [TARGET]** Locate paths in the network connecting SOURCE to TARGET, to include energy profile visualizations in the dashboards. When both SOURCE and TARGET are specified, a simple search is performed including only the routes that connect both nodes. If *--paths* is passed without further specification, all possible cyclic paths along the network are searched (much slower). If only SOURCE is specified, all cyclic paths are also searched, and then filtered to only keep these with connections to SOURCE.
- **--cutoff_path CUTOFF**. Maximum depth for two-ended path search (number of intermediate nodes between SOURCE and TARGET), default is 4.
- **--outfile FILENAME**. Name of the output HTML file containing the dashboard.
- **--title TITLE**. Title shown in the dashboard.

### Path specification: sources and targets
Path location in *amk_rxreader* (either via the commandline interface, with the **--paths** argument, or through directly calling **add_paths()** in a Python script) allows a somehow flexible specification of source and target nodes.
+ *MINX* and *PRODX* labels can be used to specify a single source or target node.
+ For products, a formula *A+B* (no blank spaces) can also be specified, thus locating ALL *PRODX* tags matching the requested formula. Formulas can be found in the *RXNet* files or in the *rxn_all.txt* file.
+ Several sources (or targets) can be specified at once, searching for all possible combinations between sources and targets.
+ When using `amk_gen_view.py`, multiple labels or product formulas should be separated by commas.
+ When calling the Python function `add_paths(G, [sources], [targets])`, multiple labels or product formulas are given as lists.

### Examples of usage
The following example shows how to create interactive plots from RXNet.cg file including all paths found at low level for Formic Acid (FA):

`$amk_gen_view.py FINAL_LL_FA RXNet.cg --b --paths`

While this one creates the corresponding plots for the paths that connect MIN1 with the H<sub>2</sub> + CO<sub>2</sub> products:

`$amk_gen_view.py FINAL_LL_FA RXNet.cg --paths MIN1 H2+CO2`

## Dependencies
+ NetworkX 
+ Bokeh (>= 2.3.2)
+ jsmol\_bokeh\_extension
+ NodeJS (>= 14.0.0)
+ matplotlib
+ numpy 
+ sqlite3



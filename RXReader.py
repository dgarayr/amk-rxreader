'''April 2021, Diego Garay-Ruiz, Institute of Chemical Research of Catalonia
Module to read reaction networks from AutoMeKin, generating a NetworkX.Graph object
which can be then translated into a energy profile.
In contrast with the original implementation, here everything is read from files in
the FINAL_LL_/FINAL_HL_ folders, which have self-consistent indexing.
To keep it straightforward, only RXNet file & min.db, ts.db and prod.db files shall be read'''
import numpy as np
import sqlite3
import matplotlib.pyplot as plt
import matplotlib.collections as collections
import matplotlib.text
import networkx as nx

# Constant definitions (from scipy.constants, redefined to avoid additional dependencies)
hartree_J = 4.3597447222071e-18
Navogadro = 6.02214076e+23
hartree_kcal = hartree_J*Navogadro/4184

# Helper functions
def xyz_line_parse(xyzline):
	'''Direct parsing of a raw XYZ-format line to format it as string/float/float/float
	Input:
	- xyzline. String, directly read from file.
	Output:
	- List with x,y,z coordinates formatted as numbers'''
	split_line = xyzline.split()
	at = split_line[0]
	xyz = [float(item) for item in split_line[1:]]
	return [at] + xyz 

def molden_vibration_parser(moldenfile):
	'''Parse a MOLDEN file containing vibrational structures.
	Input:
	- moldenfile. String, filename to be read.
	Output:
	- freqs. List of floats containing frequencies parsed from the file.
	- coords. List of lists containing XYZ coordinates.
	- displacement. List of lists of lists containing XYZ coordinates for each atomic displacement.'''
	with open(moldenfile,"r") as fmold:
		dump = fmold.read()
	sel_list = dump.split("]")[2:]
	proc_list = [item.split('[')[0].strip() for item in sel_list]
	# Now we can process every item
	freqs = [float(entry) for entry in proc_list[0].split()]
	coords = [xyz_line_parse(line) for line in proc_list[1].split("\n")]
	# Get no. of atoms from coordinates and use this to handle vibrations as a list of lists
	displ_block = proc_list[2].split("\n")
	nlines = len(coords) + 1
	displacements = [displ_block[ii+1:ii+nlines] for ii in range(0,len(displ_block),nlines)]
	for jj,displ in enumerate(displacements):
		displacements[jj] = [line.split() for line in displ]
	return freqs,coords,displacements

# Querying functions
def query_energy(dbcursor,filterstruc,tablename,add_zpe=False):
	'''Get energy and ZPEs from a SQL table and sum them.
	Input:
	- dbcursor. SQLite3 cursor for a DB connection.
	- filterstruc. String, SQL statement of the type WHERE to filter a given entry
	- tablename. String, name of the table in the SQL file.
	- add_zpe. Boolean, if True, sum zero-point vibrational energy to the energy results
	Output:
	- energies. List of floats containing queried energies. In principle it is expected to have 
	  one-element lists, but it is returned like this for safety.'''
	qtemp = "SELECT energy,zpe FROM %s " % tablename
	if (filterstruc):
		qtemp += filterstruc
	matches = dbcursor.execute(qtemp).fetchall()
	if (add_zpe):
		energies = [sum(match) for match in matches]
	else:
		energies = [match[0] for match in matches]
	return energies

def query_all(dbcursor,filterstruc,tablename,add_zpe=False):
	'''Get energy and ZPEs from a SQL table and sum them
	Input:
	- dbcursor. SQLite3 cursor for a DB connection.
	- filterstruc. String, SQL statement of the type WHERE to filter a given entry
	- tablename. String, name of the table in the SQL file.
	- add_zpe. Boolean, if True, sum zero-point vibrational energy to the energy results
	Output:
	(In principle it is expected to have one-element queries, but we return lsits for safety)
	- energies. List of floats containing queried energies. 
	- geometry. List of strings containing newline-separated blocks for Cartesian coordinates of a molecule.
	- frequencies. List of strings containing newline-separated blocks for all frequency values of a molecule
	- 
	'''
	qtemp = "SELECT energy,zpe,geom,freq FROM %s " % tablename
	if (filterstruc):
		qtemp += filterstruc
	matches = dbcursor.execute(qtemp).fetchall()
	if (add_zpe):
		energies = [sum(match[0:2]) for match in matches]
	else:
		energies = [match[0] for match in matches]
	geometry = [match[2] for match in matches]
	frequencies = [match[3] for match in matches]
	return energies,geometry,frequencies

# Reaction network reading
def RX_parser(workfolder,rxnfile="RXNet"):
	'''Direct parsing of RXNet files generated by AutoMeKin, preparing the general structure (connectivity) to later
	instantiate the network
	Input:
	- workfolder. String, folder where the RXNet file and the SQL databases will be read from
	- rxnfile. String, specific name of the RXNet file to be used
	Output:
	- data. List of lists, containing the tags and indices of the node - edge - node pairs in the reaction
	network required to build the corresponding graph'''
	froute = "%s/%s" % (workfolder,rxnfile)
	with open(froute,"r") as frxn:
		# Structure of the file: TS, DE value and rxn path
		# Four possible path heuristics:
		# MIN x <--> MIN y
		# MIN x <--> PRa: A + B
		# PRa: A + B <--> MIN x
		# PRa: A + B <--> PRc: C + D
		tags = []
		indices = []
		dump = [item.strip() for item in frxn.readlines()[2:]] # skipping header
		# use --- to split the reaction path separator
		dump_proc = [item.split("---") for item in dump]
		for line in dump_proc:
			leftside,rightside = [item.strip("<>-").split() for item in line]
			ts = int(leftside[0])
			# Check whether we have a product or a minimum
			if (leftside[2] == "MIN"):
				m1 = int(leftside[3])
				t1 = "MIN"
			else:
				# We have PRa: and we have to extract the integer a
				m1 = int(leftside[2].strip(":").replace("PR",""))
				t1 = "PROD"
			# do the same for the other side
			if (rightside[0] == "MIN"):
				m2 = int(rightside[1])
				t2 = "MIN"
			else:
				m2 = int(rightside[0].strip(":").replace("PR",""))
				t2 = "PROD"
			tags.append(["TS",t1,t2])
			indices.append([ts,m1,m2])
		# fetch tags MIN/TS/PROD and the corresponding indices for each 
		data = [tags,indices]
	return data

def RX_builder(workfolder,data,orig_selec_mode=False):
	'''From the connectivity data parsed in RX_parser(), generate the graph structure and querying information from the corresponding 
	SQL databases to add information (energy, geometry and lists of frequencies) to the network. Relative energies are also computed here,
	taking the lowest-energy intermediate as reference.
	Input:
	- workfolder. String, folder where the RXNet file and the SQL databases will be read from
	- data. List of lists, containing the tags and indices of the node - edge - node pairs in the reaction
	network required to build the corresponding graph -> RX_parser() direct output.
	- orig_selec_mode. Boolean, if True, remove entries starting from PROD structures following original AMK coding
	Output:
	- G. NetworkX.Graph() object including intermediate and TS information embedded in every node and edge, as fetched
	from the corresponding databases. Additional information used on graph creation (e.g. the reference structure) is passed
	as Graph properties.
	'''
	network_info = {}
	# Establish DB connections and fetch all required information to generate a NetworkX graph
	# Prepare DB connections, as read-only
	dbnames = ["file:" + workfolder + "/%s.db?mode=ro" % entity for entity in ["min","ts","prod"]]
	dbconnections = [sqlite3.connect(db,uri=True) for db in dbnames]
	dbmin,dbts,dbprod = [dbcon.cursor() for dbcon in dbconnections]
	dbdict = {"min":dbmin, "ts":dbts, "prod":dbprod}
	
	# We first need to have a energy reference: for consistency with the original implementation,
	# we will be using the middle column element with the minimum index, which due to ordering has the minimum energy
	smin = min([entry[1] for entry in data[1]])
	e_ref = query_energy(dbmin,"WHERE id==%s" % smin,"min")[0]

	# the units of this energy are kcal/mol from MOPAC (LL) and hartree from G09 (HL)
	if ("LL" in workfolder):
		network_info["e_units"] = "kcal/mol"
	else:
		network_info["e_units"] = "hartree"

	# save in output dict
	network_info.update({"ref_struc":"MIN%d" % smin, "ref_energy":e_ref})
	# Build the graph
	nodelist = []
	edgelist = []
	node_build_dict = {}

	for tag,ndx in zip(data[0],data[1]):
		# Original implementation avoids routes starting with PROD: allow to keep them
		# Prepare queries and analyze the right side which can be PROD or MIN, treated differently
		ts_ii,side1_ii,side2_ii = ndx
		qts,qm1,qm2 = ["WHERE id==%s" % ival for ival in ndx]
		e_ts,geom_ts,freq_ts = [elem[0] for elem in query_all(dbdict["ts"],qts,"ts")]
		# use the lowercased tags as selectors for the DBs
		sel_m1,sel_m2 = [sel.lower() for sel in tag[1:]]

		if (sel_m2 == "prod" and orig_selec_mode):
			# Skip cases starting with PROD for consistency IN original implementation
			continue

		e_m1,geom_m1,freq_m1 = [elem[0] for elem in query_all(dbdict[sel_m1],qm1,sel_m1)]
		e_m2,geom_m2,freq_m2 = [elem[0] for elem in query_all(dbdict[sel_m2],qm2,sel_m2)]

		# check for self-loops and remove them: CONTINUE if we have same index and same selector
		if ((side1_ii == side2_ii) and (sel_m1 == sel_m2)):
			continue

		# Compute relative energies and generate consistent labels
		relvals = [e - e_ref for e in [e_ts,e_m1,e_m2]]
		labels = [name + str(ii) for name,ii in zip(tag,ndx)]
		
		# Construct energy dictionary and a full edge constructor with connections, name and energy parameters
		nn1,nn2 = labels[1:3]
		# Dictionary updaters
		if (nn1 not in node_build_dict.keys()):
			nodelist.append((nn1,{"name":nn1,"energy":relvals[1],"geometry":geom_m1,"frequencies":freq_m1}))
		if (nn2 not in node_build_dict.keys()):
			nodelist.append((nn2,{"name":nn2,"energy":relvals[2],"geometry":geom_m2,"frequencies":freq_m2}))
		edgelist.append((nn1,nn2,{"name":labels[0],"energy":relvals[0],"geometry":geom_ts,"frequencies":freq_ts}))

	# Now generate the graph and then add the corresponding node energies
	G = nx.Graph()
	G.add_edges_from(edgelist)
	G.add_nodes_from(nodelist)
	# Add the network_info dict as a Graph.Graph property
	G.graph.update(network_info)
	return G

def vibr_displ_parser(workfolder,G):
	'''Add vibrational displacements to a existing graph, for further visualization. This information is taken from the
	MOLDEN files stored in the normal_modes/ folder as generated by AutoMeKin. PROD structures do not have this vibrational info.
	Input:
	- workfolder. String, folder where the RXNet file and the SQL databases will be read from
	- G. NetworkX.Graph() as generated by RX_builder() -> connectivity, energy, geometry & frequencies.
	Output:
	The G object is modified in-place.
	'''
	nm_folder = workfolder + "/normal_modes"

	# Nodes first, then edges, remembering that there is no info for PROD species
	for nd in G.nodes(data=True):
		if ("MIN" in nd[0]):
			ndid = int(nd[0].replace("MIN",""))
			nm_file = nm_folder + "/MIN%04d.molden" % ndid
			frq,coords,displ = molden_vibration_parser(nm_file)
			nd[1]["vibr_displace"] = displ

	for ed in G.edges(data=True):
		tsid = int(ed[2]["name"].replace("TS",""))
		nm_file = nm_folder + "/TS%04d.molden" % tsid
		frq,coords,displ = molden_vibration_parser(nm_file)
		ed[2]["vibr_displace"] = displ
	return None

def graph_plotter(G):
	'''Basic MPL plotting for reaction networks generated with RX_builder()
	Input:
	- G. NetworkX.Graph() as generated by RX_builder() -> connectivity, energy, geometry & frequencies.
	Output:
	- fig, ax. Matplotlib figure and axis.'''
	fig = plt.figure()
	ax = fig.add_subplot(111)
	# We need position layout & node energies for coloring
	posx = nx.shell_layout(G)
	energvals = [entry[1] for entry in nx.get_node_attributes(G,"energy").items()]
	nx.draw(G,posx,with_labels=False,node_color=energvals,alpha=0.5,ax=ax)
	nx.draw_networkx_labels(G,posx,nx.get_node_attributes(G,"name"),font_weight="bold",ax=ax)
	edgelabs = nx.get_edge_attributes(G,"name")
	nx.draw_networkx_edge_labels(G,posx,edgelabs,font_color="red",ax=ax)
	return fig,ax

def graph_plotter_interact(G,figsize=(10,10)):
	'''Interactive MPL plotting for reaction networks generated with RX_builder(), in which nodes can be clicked to get 
	energy values, in kcal/mol.
	Input:
	- G. NetworkX.Graph() as generated by RX_builder() -> connectivity, energy, geometry & frequencies.
	- figsize. Tuple of floats, size of the resulting plot
	Output:
	- fig, ax. Matplotlib figure and axis.
	'''

	# Set nested event response functions here so they can freely access all params in the function
	
	def annotator(axis,text,loc):
		'''
		Adds an Annotation artist in a requested location, with a given text.
		'''
		note = matplotlib.text.Annotation(text,loc,backgroundcolor="#FF1493",fontsize=14)
		axis.add_artist(note)
		return note
	
	def onpickx(event):
		'''Event picker, responsive to nodes (PathCollection from plt.scatter) or edges (LineCollection from ArrowPaths).
		Adds annotations for the energy of the nodes/edges that are clicked. If the note does already exist, it is deleted.
		Returns the index of the selection.'''
		if isinstance(event.artist,collections.PathCollection):
			current_artist = event.artist
			element_type = "NODE"
		elif isinstance(event.artist,collections.LineCollection):
			current_artist = event.artist
			element_type = "EDGE"
		ind = event.ind[0]
		# Change reactivity for nodes or edges
		if (element_type == "NODE"):
			xx,yy = current_artist.get_offsets()[ind]
			idname = map_nodes[ind]
			
		elif (element_type == "EDGE"):
			v0,v1 = current_artist.get_paths()[ind].vertices
			# we want the middle point to place the label
			xx,yy = 0.5*(np.array(v0) + np.array(v1))
			idname = map_edges[ind]
			
		if (idname not in note_track.keys()):
			if (element_type == "NODE"):
				energy,objname = [G.nodes[idname][prop] for prop in ["energy","name"]]
			elif (element_type == "EDGE"):
				energy,objname = [G.edges[idname[0],idname[1]][prop] for prop in ["energy","name"]]
			if (unit_change):
				energy = energy*hartree_kcal
			estring = "%.2f" % energy
			notelabel = "%s \n (%.2f)" % (objname,energy)
			noteobj = annotator(ax,notelabel,(xx,yy))
			note_track[idname] = noteobj
		else:
			current_note = note_track[idname]
			current_note.remove()
			del note_track[idname]
		ax.figure.canvas.draw_idle()
		return ind
	
	# Unit checking	
	unit_change = G.graph["e_units"] == "hartree"
	note_track = {}
	# Figure generation
	fig = plt.figure(figsize=figsize)
	ax = fig.add_subplot(111)
	ax.set_frame_on(False)
	posx = nx.shell_layout(G)
	# map indices to keys for nodes and edges (nodes are taken from posx)
	map_nodes = {ii:name for ii,name in enumerate(posx.keys())}
	map_edges = {ie:ed for ie,ed in enumerate(G.edges)}
	# fetch energies
	energvals = [entry[1] for entry in nx.get_node_attributes(G,"energy").items()]
	nodecol = nx.draw_networkx_nodes(G,posx,node_size=500,ax=ax,alpha=0.7,node_color=energvals)
	nx.draw_networkx_labels(G,posx,font_size=16,font_weight="bold")
	edgecol = nx.draw_networkx_edges(G,posx)
	nx.draw_networkx_edge_labels(G,posx,nx.get_edge_attributes(G,"name"),font_size=16,font_color="red")
	# Make the plot reactive
	nodecol.set_picker(True)
	edgecol.set_picker(True)
	fig.canvas.mpl_connect('pick_event',onpickx)

	# axis rescaling avoids border clipping for nodes
	rescaling = 1.2
	ax.set_xlim([rescaling * x for x in ax.get_xlim()])
	ax.set_ylim([rescaling * y for y in ax.get_ylim()])
	return fig,ax

# Profile generation functions
def node_position(edge,pos_dict,x0,cntr):
	'''Assignment of node positions for profile generation, inspired by the gnuplot scripts built in AutoMeKin. Sign assignment allows to set 
	nodes at both sides of the plot by starting by a single node, having a more compact plot.
	Input:
	- edge. Tuple of strings defining an edge whose nodes we are plotting.
	- pos_dict. Dictionary mapping node names to the position of the 1st point on the segment, to position structures that 
	  were already defined
	- x0. Float, default initial position for the first node in the edge.
	- cntr. Integer, a counter to handle signs.
	Output:
	- [n1_x0,n1_x1]. List of floats, x positions for the segment of the first node.
	- [n2_x0,n2_x1]. List of floats, x positions for the segment of the second node.
	- sign. Integer, +-1, current value of the sign.
	-'''
	# Check whether the positions are already assigned
	n1,n2 = edge
	try:
		n1_x0 = pos_dict[n1]
	except:
		n1_x0 = x0
	# In the second node, only keep track for minima
	try:
		n2_x0 = pos_dict[n2]
		sign = np.sign(n2_x0 - n1_x0)
	except:
		# decide the sign according to the counter
		parity = cntr % 2
		if (parity == 0):
			sign = 1
		else:
			sign = -1
		n2_x0 = n1_x0 + sign*8
	# Check that positions don't overlap: if they do, move the second but don't track it
	if (n1_x0 == n2_x0):
		print("Overlapping positions:",n1_e0,n2_x0,edge)
	# now provide all X-positions: n1_x0, n1_x1, n2_x0, n2_x1 and the sign
	n1_x1,n2_x1 = [n_x0 + 2 for n_x0 in [n1_x0,n2_x0]]
	return [n1_x0,n1_x1],[n2_x0,n2_x1],sign

def line_iterator(G,node,pos_dict,used_ts,x0=0):
	'''For a given node in the graph, detects its inmediate neighbors and prepares the corresponding lines in the graph
	(node A, edge AB and node B, as a XY array to be then passed to matplotlib), for any number of neighbors. Labels
	with names are also generated.
	Input:
	- G. NetworkX.Graph() as generated by RX_builder() -> connectivity, energy, geometry & frequencies.
	- node. String, name of the node whose neighbors are being currently detected to draw.
	- pos_dict. Dictionary mapping node names to the position of the 1st point on the segment, to position structures that 
	  were already defined
	- used_ts. List of strings, containing the TSx names for the edges that have already been drawn (as TSs must not be repeated)
	- x0. Float, default initial position for the first node.
	Output:
	- list_arrs. List of XY arrays for each node A/edge AB/node B combination found from 1st neighbor search from /node/.
	- list_labels. List of labels for each node A/edge AB/node B combination.
	- neighborhood. List of strings with the neighbors of the input node.
	'''
	list_arrs = []
	list_labels = []
	# Check positioning
	neighborhood = list(G.neighbors(node))
	neigh_edges = [(node,neigh) for neigh in neighborhood]
	cnt = 0
	for ie,ed in enumerate(neigh_edges):     
		tsname = G.edges[ed]["name"]
		if (tsname in used_ts):
			continue
		used_ts.append(tsname)
		# horizontal positioning 
		n1pos,n2pos,sgn = node_position(ed,pos_dict,x0,cnt)
		tspos = [n1x+sgn*4 for n1x in n1pos]
		# Don't keep track of products: these can be repeated along the plot
		for nd,npos in zip(ed,[n1pos,n2pos]):
			if ("MIN" in nd):
				pos_dict[nd] = npos[0]
		# vertical positioning: energies
		n1_e = G.nodes[ed[0]]["energy"]
		n2_e = G.nodes[ed[1]]["energy"]
		ts_e = G.edges[ed]["energy"]
		# prepare XY points & sort them by the X column for consistent plot generation
		x_vals = n1pos + tspos + n2pos
		y_vals = [n1_e]*2 + [ts_e]*2 + [n2_e]*2
		xyarray = np.array([x_vals,y_vals]).T
		mask = xyarray[:,0].argsort()
		xyarray = xyarray[mask]
		list_arrs.append(xyarray)
		# manage label list, /w duplicities, & reorder it with the same mask as before
		lablist = [ed[0]]*2 + [tsname]*2 + [ed[1]]*2
		lablist = np.array(lablist)[mask]
		list_labels += [lablist]
		cnt += 1
	return list_arrs,list_labels,neighborhood

def full_profile(G,startnode):
	'''Applies line_iterator() through the whole network by iterating along the neighbors until no
	connections remain to be read. The graph must be fully connected, as it should in this kind of setup.
	Input:
	- G. NetworkX.Graph() as generated by RX_builder() -> connectivity, energy, geometry & frequencies.
	- startnode. String, name of the first node to be analyzed in the recursive neighbor search protocol.
	Output:
	- list_profiles. Full list of XY arrays for each node A/edge AB/node B combination 
	- list_labels. Full list of strings with labels for each node A/edge AB/node B combination 
	 '''

	# Here we can iterate along the whole network
	# define the intermediate lists & dicts
	pos_dict = {}
	tslist = []
	x0 = 0
	next_gen = []
	list_profiles,list_labels,next_nodes = line_iterator(G,startnode,pos_dict,tslist,x0)	
	update_flag = bool(list_profiles)
	while (update_flag):
		current_state = []
		nw_profiles = []
		nw_labels = []
		for nwstart in next_nodes:
			add_profiles,add_labels,nw_nodes = line_iterator(G,nwstart,pos_dict,tslist,x0)
			next_gen += [item for item in nw_nodes if item not in next_gen]
			nw_profiles += add_profiles
			nw_labels += add_labels
			current_state.append(bool(add_profiles))
		list_profiles += [prof for prof in nw_profiles]
		list_labels += nw_labels
		update_flag = np.any(current_state)    
		next_nodes = next_gen
	# Unit handling
	unit_change = G.graph["e_units"] == "hartree"
	if (unit_change):
		for prof in list_profiles:
			prof[:,1] *= hartree_kcal
	return list_profiles,list_labels

def profplotter(arrlist,lablist,put_energy=False,figsize=(10,10)):
	'''Matplotlib plotting of the XY arrays generated by full_profile()/line_iterator()
	Input:
	- arrlist. Full list of XY arrays for each node A/edge AB/node B combination, from full_profile()
	- lablist. Full list of strings with labels for each node A/edge AB/node B combination, from full:profile().
	- put_energy. Boolean, if True add additional annotations with the energy of each node and edge.
	- figsize. Tuple of floats, figure sizing.
	Output:
	- fig,ax. Matplotlib figure and axis
	'''
	# Pure plotting function
	# shifts for plotting
	xshift = 1
	yshift = 2
	cmap = plt.get_cmap("tab10")
	fig,ax = plt.subplots(nrows=1,ncols=1,figsize=figsize)
	ax.set_frame_on(False)
	ax.axes.get_xaxis().set_visible(False)
	ax.get_yaxis().tick_left()
	ax.axes.grid(b=True,which='both',linestyle='--',c="silver")
	for ii,(arr,labs) in enumerate(zip(arrlist,lablist)):
		ax.plot(arr[:,0],arr[:,1],"--",c=cmap(ii))
		# wider lines?
		for jj in range(3):
			single_line = arr[2*jj:2*jj+2]
			ax.plot(single_line[:,0],single_line[:,1],lw=4,c=cmap(ii))
		# prepare labels
		sel_labs = labs[::2]
		sel_locs = arr[::2,:]
		for loc,text in zip(sel_locs,sel_labs):
			loc[0] += xshift
			ax.annotate(text,loc,horizontalalignment='center',verticalalignment='bottom')
			evalue = "%.2f" % loc[1]
			if (put_energy):
				ax.annotate(evalue,[loc[0],loc[1]-yshift],horizontalalignment='center',verticalalignment='top').draggable()
	return fig,ax

# Functions to fetch geometries
def xyz_generator(item_select):
	'''From a node or edge, extract the "geometry" fiels in a xyz file, indicating name & energy in comment line
	Input:
	- item_select. Node or edge selected from the nx.Graph object, taken via G.nodes[NODE] or G.edges[(NODE_A,NODE_B)]
	Output:
	- xyzblock. String, newline-separated XYZ-compliant block.
	'''
	# get no. of atoms
	geoblock = item_select["geometry"]
	Nat = geoblock.count("\n") + 1
	xyzblock = "%d\n" % Nat
	xyzblock += "%s    energy=%.2f \n" % (item_select["name"],item_select["energy"])
	xyzblock += item_select["geometry"]
	return xyzblock

def profile_geometrist(G,label_list,out_folder="xyz_profiles"):
	'''From the list of labels generated by full_profile(), fetch all geometries and join
	them in XYZ files for the 3-structure reaction stage.
	Input:
	- G. NetworkX.Graph() as generated by RX_builder() -> connectivity, energy, geometry & frequencies.
	- lablist. Full list of strings with labels for each node A/edge AB/node B combination, from full:profile().
	- out_folder. String, folder to write XYZ files to.
	Output:
	Generates XYZ files in the requested folder
	'''
	for lab in label_list:
		px = lab[::2] # as these are duplicated
		out_name = "_".join(px)
		sel_n1 = G.nodes[px[0]]
		sel_n2 = G.nodes[px[2]]
		sel_ts = G.edges[(px[0],px[2])]
		join_xyz = "\n".join([xyz_generator(elem) for elem in [sel_n1,sel_ts,sel_n2]])
		froute = "%s/%s.xyz" % (out_folder,out_name)
		with open(froute,"w+") as fxyz:
			fxyz.write(join_xyz)
	return None